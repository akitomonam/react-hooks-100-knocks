### 課題: `useCallback`を使って関数をメモ化する

#### 目的:
- `useCallback`フックを使用して、関数をメモ化（キャッシュ）する方法を学ぶ。
- 不必要な再生成を避け、パフォーマンスを最適化する方法を理解する。
- 子コンポーネントへのプロパティとして関数を渡す際の再レンダリングを防ぐ。

#### 要件:
1. **`useCallback`の導入**:
   - `useCallback`フックをインポートし、関数をメモ化するために使用する。
2. **関数のメモ化**:
   - `useCallback`を使用して、依存配列の値が変更されない限り、同じ関数インスタンスを再利用する。
3. **依存配列の設定**:
   - `useCallback`の依存配列を設定し、特定の依存関係が変更されたときのみ関数が再生成されるようにする。
4. **パフォーマンスの確認**:
   - メモ化によって関数が必要な場合にのみ再生成されることを確認し、パフォーマンスの向上を確認する。

#### 役立つ場面:
- **子コンポーネントへのプロパティとして関数を渡す場合**:
   - 親コンポーネントが再レンダリングされても、子コンポーネントへのプロパティとして渡される関数のインスタンスが変わらないようにする。
- **パフォーマンスの最適化**:
   - 頻繁に再生成されるとパフォーマンスに影響がある関数をメモ化することで、アプリケーションのパフォーマンスを最適化する。
- **依存関係の管理**:
   - 特定の依存関係が変更されたときにのみ関数が再生成されるようにすることで、不要な再計算や再生成を避ける。

#### 実装ステップ:
1. **コンポーネントの作成**:
   - Reactコンポーネントを作成する。
2. **関数の定義**:
   - メモ化が必要な関数を定義する。
3. **`useCallback`の導入**:
   - `useCallback`フックを使用して関数をメモ化する。
4. **依存配列の設定**:
   - `useCallback`の依存配列を設定し、特定の依存関係が変更されたときにのみ関数が再生成されるようにする。
5. **関数の使用**:
   - メモ化された関数をコンポーネント内で使用し、子コンポーネントへのプロパティとして渡す。

### 具体例のフロー
1. **コンポーネントの基本構造**:
   - Reactコンポーネントを作成し、基本的なレイアウトを定義します。
2. **関数の定義とメモ化**:
   - 例えば、ユーザーのクリックハンドラやデータのフィルタリング関数を定義し、`useCallback`でメモ化します。
3. **依存配列の設定**:
   - `useCallback`の依存配列を設定し、特定の依存関係が変更されたときにのみ関数が再生成されるようにします。
4. **関数の使用と確認**:
   - メモ化された関数をコンポーネント内で使用し、必要な場合にのみ再生成されることを確認します。

### 実用例:
1. **クリックハンドラのメモ化**:
   - ボタンのクリックハンドラをメモ化し、親コンポーネントが再レンダリングされても同じ関数インスタンスを再利用します。
2. **フィルタリング関数のメモ化**:
   - 大規模な配列のフィルタリング関数をメモ化し、フィルタ条件が変更されたときにのみ再生成されるようにします。
3. **APIリクエスト関数のメモ化**:
   - APIリクエストを行う関数をメモ化し、必要な場合にのみ再生成されるようにします。

### 具体的な例:
例えば、ユーザーのクリックハンドラをメモ化する場合を考えます。

```javascript
import React, { useCallback } from 'react';

const MyComponent = ({ onButtonClick }) => {
  return (
    <button onClick={onButtonClick}>Click me</button>
  );
};

const ParentComponent = () => {
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []);

  return (
    <div>
      <MyComponent onButtonClick={handleClick} />
    </div>
  );
};

export default ParentComponent;
```
コンポーネント記述方法  
アロー関数が多いっぽい。本家もアローらしい。そこまでの違いはないっぽい。
若干constのほうが遅いらしい。export defaultもconstでは使えない。
ではなぜ？constを使用する？
- https://zenn.dev/seya/articles/0317b7a61ee781  
- https://qiita.com/yuinore/items/a6fe79fafa51a0440e6a#const-%E3%81%A8%E3%82%A2%E3%83%AD%E3%83%BC%E9%96%A2%E6%95%B0%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%8F-function-%E3%81%A7%E6%9B%B8%E3%81%8F  
- https://zenn.dev/rgbkids/books/0b75c912d8ac70/viewer/25f0ac
#### このコードの挙動:
- **`useCallback`の使用**:
  - `useCallback`フックを使用して、`handleClick`関数をメモ化します。
  - 依存配列が空のため、`ParentComponent`が再レンダリングされても`handleClick`関数は再生成されません。
- **プロパティとしての関数の使用**:
  - メモ化された`handleClick`関数を`MyComponent`のプロパティとして渡します。

### まとめ:
- **`useCallback`の使用**:
  - `useCallback`フックを使用することで、関数のメモ化が可能となり、パフォーマンスを最適化できます。
- **依存配列の設定**:
  - `useCallback`の依存配列を適切に設定することで、必要な場合にのみ関数が再生成されます。
- **実用例**:
  - クリックハンドラ、フィルタリング関数、APIリクエスト関数など、頻繁に再生成されるとパフォーマンスに影響がある関数に対して有効です。

`useMemo`と`useCallback`は、どちらもReactのフックで、計算結果や関数のメモ化に使用されます。両者の違いと使用する場面について詳しく説明します。

### `useMemo`と`useCallback`の違い

#### `useMemo`
- **目的**: 計算結果をメモ化するために使用します。
- **使い方**: 高価な計算（コストが高い計算）の結果をメモ化し、再レンダリングのたびに再計算されないようにします。
- **返り値**: `useMemo`は計算結果を返します。

**例**:
```javascript
import React, { useMemo } from 'react';

const MyComponent = ({ numbers }) => {
  const total = useMemo(() => {
    return numbers.reduce((acc, number) => acc + number, 0);
  }, [numbers]);

  return (
    <div>
      <h1>Total: {total}</h1>
    </div>
  );
};

export default MyComponent;
```

#### `useCallback`
- **目的**: 関数をメモ化するために使用します。
- **使い方**: 子コンポーネントに渡すコールバック関数や、再生成するとパフォーマンスに影響がある関数をメモ化します。
- **返り値**: `useCallback`は関数を返します。

**例**:
```javascript
import React, { useCallback } from 'react';

const MyComponent = ({ onButtonClick }) => {
  return (
    <button onClick={onButtonClick}>Click me</button>
  );
};

const ParentComponent = () => {
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []);

  return (
    <div>
      <MyComponent onButtonClick={handleClick} />
    </div>
  );
};

export default ParentComponent;
```

### 使う場面の違い

#### `useMemo`を使う場面
- **高価な計算の結果をメモ化**:
  - 配列のフィルタリング、ソート、リダクションなど計算コストの高い処理がある場合。
  - 計算結果が依存する変数が変更されたときのみ再計算が必要な場合。
  
- **例**: 
  - 配列の合計値や平均値の計算。
  - 複雑な計算やデータの変換処理。

#### `useCallback`を使う場面
- **関数をメモ化**:
  - 子コンポーネントに渡すコールバック関数がある場合。
  - 関数が再生成されるとパフォーマンスに影響が出る場合。
  - コンポーネントが再レンダリングされるたびに同じ関数インスタンスを維持したい場合。

- **例**:
  - イベントハンドラ関数（クリック、スクロール、フォームの送信など）。
  - 非同期関数やサブスクリプション関数。

### 依存配列の設定

どちらのフックも依存配列を受け取り、依存配列の値が変更されたときにのみ再計算や再生成が行われます。適切に依存配列を設定することで、パフォーマンスの最適化が可能です。

### まとめ

- **`useMemo`**:
  - 計算結果をメモ化。
  - 高価な計算の結果を再利用したいときに使用。
  - 返り値は計算結果。

- **`useCallback`**:
  - 関数をメモ化。
  - 子コンポーネントに渡す関数や、再生成のコストが高い関数を再利用したいときに使用。
  - 返り値は関数。

### 実用例の違いを理解して、適切な場面で`useMemo`と`useCallback`を使い分けることで、Reactアプリケーションのパフォーマンスを効果的に最適化できます。

「関数が再生成される」という表現は、Reactコンポーネントが再レンダリングされる際に、新しい関数インスタンスが作られることを指します。これを詳しく説明します。

### Reactの再レンダリングと関数の再生成

#### 1. Reactの再レンダリング
- **再レンダリング**: Reactコンポーネントが再レンダリングされるのは、そのコンポーネントの状態やプロパティが変わったときです。再レンダリングされると、コンポーネント内のすべての関数や変数が再評価されます。

#### 2. 関数の再生成とは？
- **関数の再生成**: コンポーネントが再レンダリングされると、そのコンポーネント内で定義されている関数も再び定義され、新しい関数インスタンスが生成されます。これは、関数の再生成（または再定義）と呼ばれます。

**例**:

```javascript
const ParentComponent = () => {
  const handleClick = () => {
    console.log('Button clicked');
  };

  return (
    <div>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
};
```

この`ParentComponent`が再レンダリングされるたびに、`handleClick`関数が再生成され、毎回新しい関数インスタンスが作成されます。

#### 3. なぜ再生成が問題になるのか？
- **子コンポーネントへの影響**: 新しい関数インスタンスが作成されると、Reactはそれを「新しい関数」と認識します。その結果、たとえ関数の内容が全く同じでも、子コンポーネントに渡された関数が異なるものと見なされ、子コンポーネントが不要に再レンダリングされることがあります。
- **パフォーマンスへの影響**: 多くの再レンダリングや再生成が発生すると、アプリケーションのパフォーマンスが低下する可能性があります。特に、同じ関数を何度も再生成する必要がない場合、無駄な処理が増えることになります。

#### 4. `useCallback`を使って再生成を防ぐ
`useCallback`を使うと、依存配列に変化がない限り、同じ関数インスタンスを再利用することができます。これにより、不要な関数の再生成を防ぎ、子コンポーネントの無駄な再レンダリングも防止できます。

**例**:

```javascript
import React, { useCallback } from 'react';

const ParentComponent = () => {
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []); // 依存配列が空のため、handleClickは再レンダリング時に再生成されない

  return (
    <div>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
};
```

この例では、`ParentComponent`が再レンダリングされても、`handleClick`関数は再生成されず、同じ関数インスタンスが再利用されます。

### まとめ
- **関数の再生成**とは、Reactコンポーネントが再レンダリングされるたびに新しい関数インスタンスが作成されることです。
- **問題点**: 不要な関数再生成は、子コンポーネントの無駄な再レンダリングやパフォーマンスの低下を引き起こす可能性があります。
- **`useCallback`の役割**: `useCallback`を使用することで、関数の再生成を防ぎ、同じ関数インスタンスを再利用することができます。これにより、パフォーマンスを最適化し、不要な再レンダリングを防ぐことができます。

# 参考
https://zenn.dev/t_jima/articles/63d2de08837908

https://tyotto-good.com/react/use-callback