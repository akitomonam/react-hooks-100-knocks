### 課題: `useEffect`を使ってコンポーネントのアンマウント時にクリーンアップ処理を行う

#### 目的:
- `useEffect`フックのクリーンアップ機能を使用して、コンポーネントがアンマウントされる時にリソースの解放やイベントリスナーの解除などを行う方法を学ぶ。
- メモリリークを防止し、パフォーマンスを最適化する方法を理解する。
- 非同期操作やイベントリスナーの管理を効果的に行う方法を学ぶ。

#### 要件:
1. **クリーンアップ処理の実装**:
   - コンポーネントがアンマウントされる時に実行されるクリーンアップ処理を`useEffect`の返り値として実装する。
2. **リソースの解放**:
   - 非同期処理やタイマー、イベントリスナーなどをクリーンアップする。
3. **依存配列の理解**:
   - `useEffect`の依存配列に応じて、クリーンアップ処理がどのタイミングで実行されるかを理解する。

#### 役立つ場面:
- **イベントリスナーの管理**:
   - コンポーネントのライフサイクルに応じて、ウィンドウやドキュメントのイベントリスナーを追加・削除する場合。
- **タイマーの管理**:
   - `setTimeout`や`setInterval`などのタイマーを使用している場合に、コンポーネントがアンマウントされる際にこれらをクリアする。
- **非同期処理のキャンセル**:
   - 非同期処理がコンポーネントのアンマウント後に完了する可能性がある場合に、リソースを解放し、メモリリークを防ぐ。
- **サードパーティライブラリのクリーンアップ**:
   - サードパーティのライブラリを使用している場合に、クリーンアップを行う。

#### 実装ステップ:
1. **コンポーネントの作成**:
   - Reactコンポーネントを作成する。
2. **`useEffect`の導入**:
   - `useEffect`フックをインポートし、必要な副作用を定義する。
3. **副作用の設定**:
   - 副作用を定義し、クリーンアップ処理が必要なリソースやイベントリスナーを設定する。
4. **クリーンアップ処理の実装**:
   - `useEffect`の返り値としてクリーンアップ処理を定義する。これは関数であり、コンポーネントがアンマウントされる際に実行される。
5. **依存配列の設定**:
   - `useEffect`の依存配列を設定し、特定の依存関係が変更されるたびにクリーンアップと再実行が行われるようにする。

### 具体例のフロー
1. **コンポーネントの基本構造**:
   - Reactコンポーネントを作成し、基本的なレイアウトを定義します。
2. **`useEffect`フックの使用**:
   - `useEffect`フックを使用して、必要な副作用を設定します。この場合、イベントリスナーの追加や非同期処理の開始などを行います。
3. **クリーンアップ処理の定義**:
   - `useEffect`の返り値として関数を定義し、この関数内でクリーンアップ処理を実行します。例えば、イベントリスナーの解除やタイマーのクリアなどを行います。
4. **依存配列の設定**:
   - `useEffect`の依存配列を設定し、特定の条件下で副作用が再実行される場合でも、前の副作用が正しくクリーンアップされるようにします。

### 実用例:
1. **イベントリスナーの追加と削除**:
   - コンポーネントがマウントされた時にウィンドウのリサイズイベントリスナーを追加し、アンマウントされた時にリスナーを解除します。
2. **タイマーの設定とクリア**:
   - コンポーネントがマウントされた時に`setInterval`を使用して定期的に実行される処理を設定し、アンマウントされた時に`clearInterval`でタイマーをクリアします。
3. **非同期処理のキャンセル**:
   - 非同期処理が実行中にコンポーネントがアンマウントされた場合に、処理をキャンセルしてリソースを解放します。

この課題を通じて、Reactコンポーネントのライフサイクルに基づいた適切なリソース管理とクリーンアップの方法を学ぶことができます。これにより、メモリリークを防ぎ、アプリケーションのパフォーマンスを向上させることができます。

# 参考
https://zenn.dev/yumemi_inc/articles/react-effect-simply-explained